12장. n-gram 파서와 전문 검색 쿼리 모드

n-gram 파서란?
단어를 형태소나 어원과 관계없이 일정 길이의 조각(Token)으로 잘라 인덱싱하는 방식
예시: "데이터" → "데이", "이터" (3-gram 기준)
형태소 분석이 어려운 한글 환경에서 특히 효과적
형태소 분석 불필요 → 빠르고 단순한 구현 가능
유사 검색 또는 부분 일치 검색에 강함
단점: 인덱스 크기 증가, 정확도 낮아질 수 있음

n-gram 성능 문제
n-gram은 인덱스 크기가 급격히 커짐
디스크 I/O 부담 → 대용량 문서 검색에서 주의 필요
너무 짧은 n-gram(n=12)은 오탐이 많아지고, n=34가 실용적

언어별 적합성
한글, 일본어, 중국어처럼 단어 경계가 불명확한 언어에 유리
영어에는 n-gram보다 형태소 기반 검색이나 불리언 검색이 더 적합


전문 검색 쿼리 모드

자연어 모드 (Natural Language Mode)
    MATCH(col) AGAINST('검색어') 형태
  	연관도 기반 검색 (TF-IDF 방식)

불리언 모드 (Boolean Mode)
    "단어1" +단어2 -단어3 처럼 검색 논리를 직접 제어
    연산자: + 필수 포함 / - 제외 / * 와일드카드 / " 정확히 일치 / () 그룹핑 등

전문 검색 쿼리 관련 추가 포인트

FULLTEXT 인덱스 제약
MySQL에서 FULLTEXT 인덱스는 기본적으로 InnoDB와 MyISAM에서만 지원
최소 단어 길이(ft_min_word_len)는 기본값 4 → 너무 짧은 단어는 검색되지 않을 수 있음
한글은 FULLTEXT 인덱스에서 정상 검색이 안 될 수 있음 → n-gram 또는 외부 검색 엔진 사용 권장 (예: Elasticsearch)

MATCH AGAINST vs LIKE
MATCH AGAINST는 인덱스를 타므로 빠름
반면 LIKE '%검색어%'는 풀 테이블 스캔이라 느림

⸻

13장. 파티션과 인덱스 최적화

파티션이 필요한 경우
테이블이 너무 커서 인덱스가 메모리에 적재되지 않는 경우
주기적으로 대량 데이터 삭제가 필요한 경우 (예: 로그 테이블)
DELETE, UPDATE 성능을 인덱스 없이도 빠르게 처리하고 싶을 때

파티션 관련 실전 포인트
파티션은 WHERE 절에서 ‘파티션 키’를 써야 효과 있음
예: WHERE created_date >= '2024-06-01' ← created_date가 파티션 키여야 분할 효과 있음
파티션 키가 쿼리에 없으면 모든 파티션을 다 검색함 → 의미 없음

파티션 유지보수
파티션은 자동 관리되지 않음 → 새 파티션 주기적으로 추가 필요
예: 월별 파티션이면 ALTER TABLE ADD PARTITION 등 수동 작업 필요

파티션 테이블 제약
외래키(FK) 설정 불가
AUTO_INCREMENT 제약 존재 (파티션 키 포함 필수)
파티션은 사용하면 성능이 무조건 좋아지는 게 아님
→ 정렬이 많은 쿼리, 범위를 벗어난 쿼리는 오히려 느려짐


인덱스 주의사항
인덱스가 크면 SELECT뿐 아니라 INSERT/UPDATE/DELETE도 느려짐
무분별한 인덱스 생성은 오히려 전체 성능 저하를 유발함

파티션의 장점
인덱스의 범위를 축소하여 성능 향상
파티션 단위로 빠르게 데이터 삭제 가능 (DROP PARTITION)
로그 테이블, 이력 테이블에 적합

유니크 인덱스 제약
유니크 인덱스(Primary Key 포함)가 있는 테이블은,
파티션 키가 해당 유니크 인덱스의 모든 컬럼을 포함해야 함

<img width="540" alt="image" src="https://github.com/user-attachments/assets/4ab00880-264d-4cc8-8f5c-0243d1619eff" />
