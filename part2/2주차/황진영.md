# 11장. 쿼리 작성 및 최적화

## GROUP BY
1. WITH ROLLUP
   - GROUP BY가 사용된 쿼리에서 그루핑된 그룹별로 소계를 가져올 수 있는 기능
   - ROLLUP으로 출력되는 소계는 단순히 최종 합만 가져오는 것이 아니라 GROUP BY에 사용된 칼럼의 개수에 따라 소계의 레벨이 달라짐
   - WITH ROLLUP과 함께 사용된 GROUP BY 쿼리의 결과는 그룹별로 소계를 출력하는 레코드가 추가되어 표시됨
   - 소계 레코드의 컬럼값은 항상 NULL로 표시됨 -> 8.0버전부터는 그룹 레코드에 표시되는 NULL을 사용자가 변경할 수 있게 GROUPING() 함수 제공

## 서브쿼리
1. SELECT 절에 사용된 서브쿼리
   - SELECT 절의 서브쿼리에는 로우 서브쿼리를 사용할 수 없고, 오로지 스칼라 서브쿼리만 사용 가능 
   - 서브쿼리로 실행될 때보다 조인으로 처리할 때가 조금 더 빠르기 때문에 가능하다면 조인으로 쿼리를 작성하는 것이 좋음

## 윈도우 함수
1. LAG()와 LEAD()
   - LAG() 함수는 파티션 내에서 현재 레코드를 기준으로 n번째 이전 레코드 반환
   - LEAD() 함수는 반대로 n번째 이후 레코드 반환

## INSERT
1. INSERT IGNORE
   - INSERT 문장의 IGNORE 옵션은 저장하는 레코드의 프라이머리 키나 유니크 인덱스 칼럼의 값이 이미 테이블에 존재하는 레코드와 중복되는 경우, 그리고 저장하는 레코드의 칼럼이 테이블의 칼럼과 호환되지 않는 경우 모두 무시하고 다음 레코드를 처리할 수 있게 해줌.
   - 여러 레코드를 하나의 INSERT 문장으로 처리하는 경우 유용
   - but, 제대로 검증되지 않은 INSERT IGNORE 문장은 의도하지 않은 에러까지 모두 무시해버릴 수 있으니 주의해야 함
2. INSERT ...ON DUPLICATE KEY UPDATE
   - 프라이머리 키나 유니크 인덱스의 중복이 발생하면 UPDATE 문장의 역할을 수행하게 해줌
   - 중복된 레코드가 있다면 기존 레코드를 삭제하지 않고 기존 레코드의 칼럼을 UPDATE하는 방식으로 작동
   - 일별로 집계되는 값을 관리할 때 편리하게 사용 가능

## 프라이머리 키 선정
1. SELECT문이 더 많이 쓰이는 쿼리
   - SELECT 쿼리를 빠르게 만드는 방향으로 프라이머리 키 선정
   - SELECT에 최적화된 프라이머리 키는 단조 증가나 단조 감소 패턴과는 거리가 먼 경우가 많지만, 여전히 빈번하게 실행되는 SELECT 쿼리의 조건을 기준으로 프라이머리 키를 선택하는 것이 좋음
   - 쿼리에 맞게 필요한 인덱스들을 추가해도 시스템 전반적으로 영향도가 크지 않음
2. INSERT문이 더 많이 쓰이는 쿼리 
   - 테이블의 프라이머리 키를 단조 증가 또는 단조 감소하는 패턴의 값을 선택하는 것이 좋음
   - 인덱스의 개수를 최소화하는 것이 좋음

