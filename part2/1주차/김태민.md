11장 쿼리 작성 및 최적화

11.3.1 리터럴 표기법 문자열

리터럴 표기법 문자열간 ''뿐만 아니라 ""또한 문자열로 표기 가능
타 DB와는 다르게 문자열을 합칠때 별도의 concat함수나 ||표기를 사용하지 않아도 "d"H001", "d'00r" 등으로 문자열 표기 가능

숫자 표기시 ''들어간 텍스트 형식(ex.'10001')으로 넣어도 자동으로 타입의 변환이 발생하여 비교 가능
숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행

11.3.1 SQL연산자

= , <=> 은 동등비교 연산자지만 <=>는 NULL-SAFE연산자로 NULL을 하나의 값으로 인식하고 비교함

REGEXP연산자로 조건을 비교 할 경우 인덱스 레인지 스캔을 사용할 수 없기때문에 단독으로 사용하는 것은 성능상 좋지 않음

LIKE구문을 사용할 경우 와일드카드 문자인 %,_ 문자를 비교하기 위해서는 ESCAPE절을 추가하여야 함

11.3.3.5 타임스탬프 연산

UNIX_TIMESTAMP,FROM_UNIXTIME
UNIX_TIMESTAMP() 함수는 '1970-01-01 00:00:00'으로부터 경과된 초의 수를 반환하는 함수로 다른 운영체제나 프로그래밍 언어에서도
같은 방식으로 산출 할 경우 상호호환 가능

FROM_UNIXTIME() 함수는 인자로 전달한 타임스탬프 값을 DATETIME타입으로 변환하는 함수

11.3.3.8 GROUP_CONCAT

이전 프로젝트에서 다량의 정책, 부서를 비교할 경우 사용한적이 있는 함수로, group_concat_max_len 변수가 서버간 달라 정상작동하지 못했던
사례가 있음, 해당 방법을 사용할 경우 꼭 체크 필요

11.3.3.18 JSON_EXTRACT

JSON의 특정 필드를 가져오는 함수로 첫번째 인자는 저장된 칼럼, 도큐먼트 자체를 입력하며 두번째 인자는 가져오고자 하는 필드의 경로를 명시하여 사용

11.4.1 SELECT절 처리 순서

FROM -> WHERE -> GROUP BY -> HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT
해당 순서에 따라 작동 되므로 DISTINCT보다는 쿼리가 조금 지저분해 보여도 GROUP BY를 사용하는 것이 성능면으로 좋음




